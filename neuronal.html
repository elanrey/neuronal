<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transforma tu negocio con Inteligencia Artificial y Automatizacion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        .hero-content {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            color: white;
        }

        .hero-text {
            max-width: 800px;
            padding: 2rem;
        }

        .hero-text h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #9333ea, #3b82f6, #ffffff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textGlow 3s ease-in-out infinite alternate;
        }

        .hero-text p {
            font-size: 1.2rem;
            color: #b3b3b3;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .cta-button {
            background: linear-gradient(45deg, #9333ea, #3b82f6);
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 25px rgba(147, 51, 234, 0.3);
        }

        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(147, 51, 234, 0.4);
        }

        @keyframes textGlow {
            0% { filter: drop-shadow(0 0 20px rgba(147, 51, 234, 0.7)); }
            100% { filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.7)); }
        }

        @media (max-width: 768px) {
            .hero-text h1 {
                font-size: 2.5rem;
            }
            .hero-text p {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas"></canvas>
    
    <div class="hero-content">
        <div class="hero-text">
            <h1>Transforma tu negocio con Inteligencia Artificial y Automatizacion</h1>
            <p>Impulsa la eficiencia y el crecimiento de tu empresa con soluciones innovadoras de IA y automatización. Desde la optimización de procesos hasta la toma de decisiones estratégicas, te ayudamos a construir el futuro de tu negocio.</p>
            <button class="cta-button">Descubre cómo</button>
        </div>
    </div>
    
    

    <script>
        class NeuralNetwork {
            constructor() {
                this.canvas = document.getElementById('neuralCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.neurons = [];
                this.connections = [];
                this.mousePos = { x: 0, y: 0 };
                this.time = 0;
                this.minConnectionsPerNeuron = 2; // Mínimo de conexiones por neurona
                this.maxConnectionDistance = 200; // Distancia máxima para una conexión
                this.lastConnectionCheck = 0;
                this.connectionCheckInterval = 500; // ms
                this.inactivityActivationThreshold = 30000; // 30 segundos en milisegundos (aproximadamente, ya que 'time' es frames)

                this.resize();
                this.init();
                this.bindEvents();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }

            init() {
                this.neurons = [];
                this.connections = [];
                
                // Generar neuronas distribuidas homogéneamente
                const neuronCount = Math.floor((this.width * this.height) / 7000); // Ajustar densidad de neuronas
                
                for (let i = 0; i < neuronCount; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    
                    this.neurons.push({
                        x: x,
                        y: y,
                        size: 1.5 + Math.random() * 1.5, // Tamaño de neurona ajustado
                        activity: 0,
                        lastImpulse: 0,
                        impulseDecay: 0.94 + Math.random() * 0.03,
                        baseActivity: Math.random() * 0.02,
                        brightness: 0.005 + Math.random() * 0.005,
                        type: Math.random() > 0.15 ? 'excitatory' : 'inhibitory',
                        receivedImpulse: false,
                        isPacemaker: false,
                        nextSpontaneousImpulse: Math.random() * 15000,
                        lastSender: -1,
                        layer: 0, // Ya no hay capas, se puede mantener o eliminar
                        branchAngle: 0 // Ya no hay ramas, se puede mantener o eliminar
                    });
                }

                // Crear conexiones privilegiando conexiones hacia capas externas (tipo árbol)
                this.neurons.forEach((neuron, i) => {
                    const maxConnections = 3;
                    let connectionCount = 0;

                    // Ordenar neuronas por distancia
                    const nearbyNeurons = this.neurons
                        .map((n, idx) => ({ neuron: n, index: idx, distance: this.distance(neuron, n) }))
                        .filter(n => n.index !== i)
                        .sort((a, b) => a.distance - b.distance);

                    for (let nearby of nearbyNeurons) {
                        if (connectionCount >= maxConnections) break;
                        
                        const otherNeuron = nearby.neuron;
                        const distance = nearby.distance;
                        
                        // Preferir conexiones hacia capas externas (propagación centrífuga)
                        const layerDiff = otherNeuron.layer - neuron.layer;
                        const sameLayer = Math.abs(layerDiff) <= 1;
                        const towardsBranches = layerDiff >= 0;
                        
                        // Calcular similitud de rama para conexiones más orgánicas
                        const angleDiff = Math.abs(neuron.branchAngle - otherNeuron.branchAngle);
                        const sameBranch = angleDiff < Math.PI / 3 || angleDiff > Math.PI * 5/3;
                        
                        let connectionProbability = 0.4;
                        
                        if (neuron.isPacemaker) connectionProbability = 0.9;
                        else if (layerDiff === 1 && sameBranch) connectionProbability = 0.8; // Misma rama, capa siguiente
                        else if (layerDiff === 1) connectionProbability = 0.6; // Diferente rama, capa siguiente  
                        else if (sameLayer && sameBranch) connectionProbability = 0.5; // Misma capa y rama
                        else if (layerDiff < 0) connectionProbability = 0.2; // Conexiones hacia el centro (raras)
                        
                        const maxDistance = (150 - neuron.layer * 5);
                        
                        if (distance < maxDistance && Math.random() < connectionProbability) {
                            this.connections.push({
                                from: i,
                                to: nearby.index,
                                strength: Math.random() * 0.4 + 0.6,
                                signal: 0,
                                signalSpeed: 0.01 + Math.random() * 0.01, // Rango ajustado para ser más rápido
                                active: false,
                                lastActivation: 0
                            });
                            connectionCount++;
                        }
                    }
                    // Asegurar que cada neurona tenga al menos una conexión saliente
                    if (connectionCount === 0 && nearbyNeurons.length > 0) {
                        const closestNeuron = nearbyNeurons[0]; // La neurona más cercana ya está al principio
                        this.connections.push({
                            from: i,
                            to: closestNeuron.index,
                            strength: Math.random() * 0.4 + 0.6,
                            signal: 0,
                            signalSpeed: 0.005 + Math.random() * 0.015,
                            active: false,
                            lastActivation: 0
                        });
                        connectionCount++;
                    }
                });
                this.connectComponents(); // Asegurar que todas las neuronas estén conectadas
            }

            maintainConnections() {
                // Eliminar conexiones demasiado grandes
                this.connections = this.connections.filter(conn => {
                    const fromNeuron = this.neurons[conn.from];
                    const toNeuron = this.neurons[conn.to];
                    if (!fromNeuron || !toNeuron) return false; // Eliminar conexiones inválidas
                    return this.distance(fromNeuron, toNeuron) <= this.maxConnectionDistance;
                });

                // Asegurar un mínimo de conexiones por neurona
                this.neurons.forEach((neuron, i) => {
                    const currentConnectionsCount = this.connections.filter(conn => conn.from === i || conn.to === i).length;

                    if (currentConnectionsCount < this.minConnectionsPerNeuron) {
                        // Encontrar neuronas cercanas no conectadas
                        const potentialTargets = this.neurons
                            .map((n, idx) => ({ neuron: n, index: idx, distance: this.distance(neuron, n) }))
                            .filter(n => n.index !== i && !this.connections.some(conn => 
                                (conn.from === i && conn.to === n.index) || (conn.from === n.index && conn.to === i)
                            ))
                            .sort((a, b) => a.distance - b.distance);

                        if (potentialTargets.length > 0) {
                            const targetNeuron = potentialTargets[0];
                            this.connections.push({
                                from: i,
                                to: targetNeuron.index,
                                strength: Math.random() * 0.4 + 0.6,
                                signal: 0,
                                signalSpeed: 0.01 + Math.random() * 0.01,
                                active: false,
                                lastActivation: 0
                            });
                        }
                    }
                });
            }

            distance(a, b) {
                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
            }

            findConnectedComponents() {
                const visited = new Array(this.neurons.length).fill(false);
                const components = [];

                for (let i = 0; i < this.neurons.length; i++) {
                    if (!visited[i]) {
                        const component = [];
                        const queue = [i];
                        visited[i] = true;

                        while (queue.length > 0) {
                            const current = queue.shift();
                            component.push(current);

                            // Buscar conexiones salientes
                            this.connections.forEach(conn => {
                                if (conn.from === current && !visited[conn.to]) {
                                    visited[conn.to] = true;
                                    queue.push(conn.to);
                                }
                            });

                            // Buscar conexiones entrantes (para grafos no dirigidos o bidireccionales)
                            this.connections.forEach(conn => {
                                if (conn.to === current && !visited[conn.from]) {
                                    visited[conn.from] = true;
                                    queue.push(conn.from);
                                }
                            });
                        }
                        components.push(component);
                    }
                }
                return components;
            }

            connectComponents() {
                let components = this.findConnectedComponents();
                while (components.length > 1) {
                    const comp1 = components[0];
                    const comp2 = components[1];

                    // Encontrar la neurona más cercana entre los dos componentes
                    let closestNeuron1 = -1;
                    let closestNeuron2 = -1;
                    let minDistance = Infinity;

                    for (const n1Index of comp1) {
                        for (const n2Index of comp2) {
                            const dist = this.distance(this.neurons[n1Index], this.neurons[n2Index]);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestNeuron1 = n1Index;
                                closestNeuron2 = n2Index;
                            }
                        }
                    }

                    if (closestNeuron1 !== -1 && closestNeuron2 !== -1) {
                        // Añadir una conexión entre los dos componentes
                        this.connections.push({
                            from: closestNeuron1,
                            to: closestNeuron2,
                            strength: 0.8, // Conexión fuerte para asegurar la conectividad
                            signal: 0,
                            signalSpeed: 0.03,
                            active: false,
                            lastActivation: 0
                        });
                        // Re-evaluar los componentes conectados
                        components = this.findConnectedComponents();
                    } else {
                        // Esto no debería pasar si hay neuronas en los componentes
                        console.warn("No se pudieron encontrar neuronas para conectar entre componentes.");
                        break;
                    }
                }
            }

            maintainConnections() {
                this.neurons.forEach((neuron, i) => {
                    // Count existing connections for this neuron (both from and to)
                    const currentConnections = this.connections.filter(conn => conn.from === i || conn.to === i).length;

                    if (currentConnections < this.minConnectionsPerNeuron) {
                        // Find potential new connections
                        const potentialTargets = this.neurons.filter((otherNeuron, j) => {
                            if (i === j) return false; // Cannot connect to self
                            // Check if already connected (either direction)
                            const alreadyConnected = this.connections.some(conn =>
                                (conn.from === i && conn.to === j) || (conn.from === j && conn.to === i)
                            );
                            return !alreadyConnected;
                        });

                        if (potentialTargets.length > 0) {
                            // Sort by distance to find the closest unconnected neuron
                            potentialTargets.sort((a, b) => this.distance(neuron, a) - this.distance(neuron, b));

                            const targetNeuronIndex = this.neurons.indexOf(potentialTargets[0]); // Get index of the closest
                            
                            // Add a new connection
                            this.connections.push({
                                from: i,
                                to: targetNeuronIndex,
                                strength: Math.random() * 0.4 + 0.6,
                                signal: 0,
                                signalSpeed: 0.01 + Math.random() * 0.01,
                                active: false,
                                lastActivation: 0
                            });
                        }
                    }
                });
            }

            bindEvents() {
                window.addEventListener('resize', () => {
                    this.resize();
                    this.init();
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                });
            }

            drawNeuron(neuron, index) {
                const mouseDistance = this.distance(neuron, this.mousePos);
                const mouseInfluence = Math.max(0, 1 - mouseDistance / 150);
                
                // Manejar impulsos espontáneos para cualquier neurona
                if (this.time >= neuron.nextSpontaneousImpulse || (this.time - neuron.lastImpulse > this.inactivityActivationThreshold && !neuron.receivedImpulse)) {
                    neuron.activity = 1.0;
                    neuron.lastImpulse = this.time;
                    neuron.receivedImpulse = true;
                    neuron.nextSpontaneousImpulse = this.time + 20000 + Math.random() * 40000; // Impulso cada 20-60 segundos
                }

                // Decaimiento de la actividad después de recibir impulso
                if (neuron.receivedImpulse) {
                    neuron.activity *= neuron.impulseDecay;
                    if (neuron.activity < 0.05) {
                        neuron.receivedImpulse = false;
                        neuron.activity = neuron.baseActivity;
                    }
                } else {
                    neuron.activity = neuron.baseActivity + mouseInfluence * 0.2;
                }
                
                const activity = Math.min(1, neuron.activity + mouseInfluence * 0.3);
                
                // Colores según el tipo de neurona con mayor brillo cuando están activas
                let baseColor;
                let glowIntensity = activity;
                
                if (neuron.receivedImpulse) {
                    glowIntensity = Math.min(1, activity * 1.0); // Brillo reducido cuando reciben impulso
                }
                
                if (neuron.type === 'inhibitory') {
                    baseColor = `rgba(107, 31, 204, ${glowIntensity * (neuron.brightness + 0.01)})`;
                } else {
                    baseColor = `rgba(39, 100, 216, ${glowIntensity * (neuron.brightness + 0.01)})`;
                }

                // Glow effect más dramático para impulsos
                const glowRadius = neuron.size + (neuron.receivedImpulse ? activity * 20 : activity * 8);
                const gradient = this.ctx.createRadialGradient(
                    neuron.x, neuron.y, 0,
                    neuron.x, neuron.y, glowRadius
                );
                
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.4, neuron.receivedImpulse ? 
                    `rgba(255, 255, 255, ${activity * 0.1})` : 
                    `rgba(255, 255, 255, ${activity * 0.3})`
                );
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                this.ctx.beginPath();
                this.ctx.arc(neuron.x, neuron.y, glowRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = gradient;
                this.ctx.fill();

                // Núcleo de la neurona más brillante cuando recibe impulso
                this.ctx.beginPath();
                this.ctx.arc(neuron.x, neuron.y, neuron.size, 0, Math.PI * 2);
                const coreOpacity = neuron.receivedImpulse ? 
                    0.7 + activity * 0.02 : 
                    0.6 + activity * 0.3;
                this.ctx.fillStyle = `rgba(255, 255, 255, ${coreOpacity})`;
                this.ctx.fill();

                /*
                // Efecto de "chispa" para neuronas activas
                if (neuron.receivedImpulse && activity > 0.6) {
                    for (let i = 0; i < 6; i++) {
                        const sparkAngle = (i / 6) * Math.PI * 2;
                        const sparkDistance = 10 + Math.random() * 15;
                        const sparkX = neuron.x + Math.cos(sparkAngle) * sparkDistance;
                        const sparkY = neuron.y + Math.sin(sparkAngle) * sparkDistance;
                        this.ctx.beginPath();
                        this.ctx.arc(sparkX, sparkY, 1.5, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.9 + 0.1})`;
                        this.ctx.fill();
                    }

                    // Anillo de expansión
                    const ringRadius = activity * 25;
                    this.ctx.beginPath();
                    this.ctx.arc(neuron.x, neuron.y, ringRadius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${(1 - activity) * 0.3})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                */
            }

            drawConnection(connection) {
                const fromNeuron = this.neurons[connection.from];
                const toNeuron = this.neurons[connection.to];
                
                if (!fromNeuron || !toNeuron) return;

                // Activación de sinapsis basada en actividad neuronal alta
                const fromActivity = fromNeuron.activity;
                let shouldActivate = fromNeuron.receivedImpulse && fromActivity > 0.6 && Math.random() > 0.8;

                // Nueva lógica para evitar que los impulsos regresen al remitente
                if (shouldActivate && connection.to === fromNeuron.lastSender) {
                    // Verificar si hay otras conexiones salientes que no regresen al remitente
                    const otherOutgoingConnections = this.connections.filter(conn =>
                        conn.from === connection.from && conn.to !== fromNeuron.lastSender
                    );
                    if (otherOutgoingConnections.length > 0) {
                        // Si hay otras opciones, no activar esta conexión de retorno
                        shouldActivate = false;
                    }
                }
                
                if (shouldActivate && !connection.active) {
                    connection.active = true;
                    connection.signal = 0;
                    connection.lastActivation = this.time;
                }

                // Propagación de señal
                if (connection.active) {
                    connection.signal += connection.signalSpeed;
                    if (connection.signal >= 1) {
                        connection.active = false;
                        connection.signal = 0;
                        // Activar neurona objetivo con impulso rápido
                        toNeuron.activity = 1.0;
                        toNeuron.lastImpulse = this.time;
                        toNeuron.receivedImpulse = true;
                        toNeuron.lastSender = connection.from; // Registrar la neurona que envió el impulso
                    }
                }

                // Opacidad basada en fuerza de conexión y actividad
                const baseOpacity = connection.strength * 0.05; // Reducir opacidad base
                const activityBoost = (fromNeuron.receivedImpulse ? fromNeuron.activity * 0.05 : 0) + 
                                   (toNeuron.receivedImpulse ? toNeuron.activity * 0.05 : 0);
                const opacity = Math.min(0.05, baseOpacity + activityBoost); // Limitar opacidad máxima

                this.ctx.beginPath();
                this.ctx.moveTo(fromNeuron.x, fromNeuron.y);
                this.ctx.lineTo(toNeuron.x, toNeuron.y);
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                this.ctx.lineWidth = 1; // Reducir ancho de línea
                this.ctx.stroke();

                // Dibujar señal en movimiento más brillante
                if (connection.active && connection.signal > 0 && connection.signal < 1) {
                    const t = connection.signal;
                    const signalX = fromNeuron.x + (toNeuron.x - fromNeuron.x) * t;
                    const signalY = fromNeuron.y + (toNeuron.y - fromNeuron.y) * t;

                    const gradient = this.ctx.createRadialGradient(signalX, signalY, 0, signalX, signalY, 4);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.3, 'rgba(59, 130, 246, 0.3)');
                    gradient.addColorStop(0.7, 'rgba(147, 51, 234, 0.2)');
                    gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');

                    this.ctx.beginPath();
                    this.ctx.arc(signalX, signalY, 6, 0, Math.PI * 2);
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();

                    // Estela de la señal
                    for (let i = 1; i <= 2; i++) {
                        const trailT = Math.max(0, t - i * 0.03);
                        if (trailT > 0) {
                            const trailX = fromNeuron.x + (toNeuron.x - fromNeuron.x) * trailT;
                            const trailY = fromNeuron.y + (toNeuron.y - fromNeuron.y) * trailT;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(trailX, trailY, 4 - i * 1, 0, Math.PI * 2);
                            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.15 / i})`;
                            this.ctx.fill();
                        }
                    }
                }
            }

            render() {
                // Fondo con gradiente sutil
                const gradient = this.ctx.createRadialGradient(
                    this.width / 2, this.height / 2, 0,
                    this.width / 2, this.height / 2, Math.max(this.width, this.height) / 2
                );
                gradient.addColorStop(0, 'rgba(10, 10, 15, 1)');
                gradient.addColorStop(1, 'rgba(5, 5, 10, 1)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Dibujar conexiones primero
                this.connections.forEach(connection => this.drawConnection(connection));
                
                // Dibujar neuronas encima
                this.neurons.forEach((neuron, index) => {
                    // Añadir un movimiento aleatorio
                    const randomMovementScale = 0.5; // Ajusta este valor para más o menos movimiento
                    neuron.x += (Math.random() - 0.5) * randomMovementScale;
                    neuron.y += (Math.random() - 0.5) * randomMovementScale;

                    // Asegurar que la neurona no se salga de los límites de la pantalla
                    neuron.x = Math.max(0, Math.min(this.width, neuron.x));
                    neuron.y = Math.max(0, Math.min(this.height, neuron.y));

                    this.drawNeuron(neuron, index);
                });
            }

            animate() {
                this.time++;
                this.render();

                if (this.time - this.lastConnectionCheck > this.connectionCheckInterval) {
                    this.maintainConnections();
                    this.lastConnectionCheck = this.time;
                }

                requestAnimationFrame(() => this.animate());
            }
        }

        // Inicializar cuando la página cargue
        window.addEventListener('load', () => {
            new NeuralNetwork();
        });
    </script>
</body>
</html>